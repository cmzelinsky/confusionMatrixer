## Right now, the script is catching precisely...

## True positives, def. as:
##
##  1. Those complete matches:
##      e.g. ('entry_7',):(u'AGE',)
##  2. Those multi-code matches where the VM generates multiple hits:
##      e.g. ('entry_7',):(u'AGE, u'AGE',)

## False positives, def. as:
##  1. Those MIMs that are generated by the engine but are not found in the GS, meaning
##        -> ... value mismatches...
##          e.g. An additional MIM is generated on top of the same token, only the code is different
##               token: June -- both FEMALE_NAME, and DATE
##
##        -> ... and scope mismatches
##          THESE ARE CURRENTLY NOT BEING HANDLED BUT MUST BE.
##          Execute by string comparison:
##              EngDic has something like (e_561, e_562): DATE
##              GsDic has something like (e_562): DATE
##                  If the codes are the same and if 
##
##
## - Scope mismatches should basically almost always be counted as TP, says Henry.
## -> What I'm going to end up doing is creating a second version of the stats with the overlaps acct'd for
##
## This means, when there *are* overlaps, either they go to TP or they go to errors, so they
## need to be handled just as soon as gsDic and engDic are created

import datetime, os, xml.dom.minidom, datetime, operator, pickle, sys, libxml2, collections, repr
from xml.dom.minidom import parse
import xml.dom.minidom as minidom
import xml.etree.ElementTree
from xml.dom import minidom
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import ElementTree
from xml.etree.ElementTree import Element, tostring, SubElement, XML
from xml.etree.ElementTree import XMLParser
from lxml import etree


startTime = datetime.datetime.now()
#path = sys.argv[1]
path = "C:/Users/courtney.zelinsky/Desktop/deid"

if not os.path.exists(path):
    raise Exception('Invalid path(s)')

def findPair(fname): 
    return fname[:-3] + 'out.xml'

#truePositivesMaster = {"B~ClinicalDocument_2531456463.xml":{('entry_60', 'entry_61'): (u'ABSOLUTE_DATE',), ('entry_201', 'entry_202'): (u'ABSOLUTE_DATE',), ('entry_185', 'entry_186'): (u'ABSOLUTE_DATE',), ('entry_235', 'entry_236'): (u'ABSOLUTE_DATE',), ('entry_20', 'entry_21'): (u'ABSOLUTE_DATE',), ('entry_282',): (u'LAST_NAME',), ('entry_144', 'entry_145'): (u'ABSOLUTE_DATE',), ('entry_18', 'entry_19'): (u'ABSOLUTE_DATE',), ('entry_140', 'entry_141'): (u'ABSOLUTE_DATE',), ('entry_244', 'entry_245'): (u'ABSOLUTE_DATE',), ('entry_566',): (u'LOCATION',), ('entry_216', 'entry_217'): (u'ABSOLUTE_DATE',), ('entry_13', 'entry_14', 'entry_15'): (u'ABSOLUTE_DATE',), ('entry_85', 'entry_86'): (u'ABSOLUTE_DATE',), ('entry_131', 'entry_132'): (u'ABSOLUTE_DATE',), ('entry_256', 'entry_257'): (u'ABSOLUTE_DATE',), ('entry_388',): (u'LAST_NAME',), ('entry_8',): (u'LAST_NAME',), ('entry_271', 'entry_272'): (u'ABSOLUTE_DATE',), ('entry_7',): (u'FEMALE_NAME',), ('entry_228', 'entry_229'): (u'ABSOLUTE_DATE',), ('entry_70', 'entry_71'): (u'ABSOLUTE_DATE',), ('entry_285',): (u'AGE',), ('entry_103', 'entry_104'): (u'ABSOLUTE_DATE',)}}
#just using truePositives for testing here, but this will be the format when an error dictionary is established
#Need FP and FN from each doc, preferably in format {doc:{FP:{entry:code, entry:code, ...}, FN:{entry:code, entry:code}}}


def KWIC(truePositivesMaster):
    """Creates readable xhtml output contexts """
    
    parser = XMLParser(encoding="utf-8")

    root = TElement('root')
    html = TElement('html', parent=root)
    html.attrib['xmlns'] = "http://www.w3.org/1999/xhtml"

    #Header
    head = TElement('head', parent=html)
    title = TElement('title', text="Deid Stats Results", parent=head)
    css = TElement('link', parent=head)
    
    css.attrib['href'] = "css.css"
    css.attrib['type'] = "text/css"
    css.attrib['rel'] = "stylesheet"

    jquery = TElement('script', text="//", parent=head)
    jquery.attrib['src'] = "http://code.jquery.com/jquery-1.10.2.js"

    head.extend(css)
    head.extend(title)
    head.extend(jquery)

    #Body
    values = sorted([key for key in confusionMatrix.keys()])
    body = TElement('body', parent=html)
    h1 = TElement('h1', text="Error contexts:", parent=body)

    output = []
    
    for doc in errors:
        parsedDoc = minidom.parse(findPair(path + '\\' + doc))
        paragraphs = []
        outputParagraph = []
        wordDict = {}
        #paragraphs = parsedDoc.getElementsByTagName('paragraphs')
        contents = parsedDoc.getElementsByTagName('content')
        #looks like a bunch of <DOM Element: content at 0x3396d50> etc instances for each content node in the doc
        entryTuples = [FPtuples for FPtuples in errors[doc]['FP']]
        #print doc + ": "
        #print "entryTuples (before) : ", entryTuples
        entryTuples.extend([FNtuples for FNtuples in errors[doc]['FN']])
        #print "entryTuples (after) : ", entryTuples
        for entry in entryTuples:
            if type(entry) != tuple:
                #print "type of entry wasn't a tuple!"
                #print type(entry)
                #print "the entry type wasn't a tuple, and so attempting to reinsert " + entry + " at the same index as a tuple"
                entryTuples.insert(entryTuples.index(entry),(entry,))
                entryTuples.remove(entry)
        #all error entry tuples, looks like [('entry_60', 'entry_61'), ('entry_201', 'entry_202'), ('entry_185', 'entry_186'), ('entry_235', 'entry_236')...]
        for content in contents:
            if content.firstChild is not None:
                wordDict[content.getAttribute('ID')] = content.firstChild.nodeValue
            #entry number to token dictionary, looks like {u'entry_567': u'this ', u'entry_566': u'Boston ', u'entry_565': u'in ', u'entry_564': u'appointment '
        #print doc
        #print wordDict
        for i in range(len(wordDict)):
            # Aaaaaaaaaaaaaa new tokenization means a kind of wacky hack around this that will definitely lead to some missing parts of sentences...
            if 'entry_' + str(i) in wordDict:
            # Preprocessing (getting a problem with parser not able to handle u'<INC ', u'00:04:36> ' -type of markup in the document)
                if not '>' in wordDict['entry_' + str(i)] and not '<' in wordDict['entry_' + str(i)] and not ';' in wordDict['entry_' + str(i)]:
                    if '&' in wordDict['entry_' + str(i)]:
                        outputParagraph.append(wordDict['entry_' + str(i)].replace("&", "&amp;"))
                    else:
                        outputParagraph.append(wordDict['entry_' + str(i)])
        #for entries in entryTuples:
            #pass
            #for entry in entries:
            #looking at each entry number individually , applies the CSS individually -- not sure if i could easily apply the CSS for the full tuple?
            #if len(entries) > 1:
            #    for subentry in entries:
            #        print subentry
            #        entryTuples.append((subentry,))
            #    entryTuples.remove(entries)

        for entry in entryTuples:
            for i in range(len(wordDict)):
                if ('entry_' + str(i),) == entry : #or 'entry_' + str(i) == entry in:
                    if entry in errors[doc]['FP']:
                        if entry not in gsDic[doc]:
                            outputParagraph[i] = '<font style="background-color:red"><strong><error id="' + str(entry) + '" gs="ENGINE_ONLY_ENTRY" eng="' + str(errors[doc]['FP'][entry])  + '">' + wordDict['entry_' + str(i)] + '</error></strong></font>'
                        else:
                            outputParagraph[i] = '<font style="background-color:red"><strong><error id="' + str(entry) + '" gs="' + str(gsDic[doc][entry]) + '" eng="' + str(errors[doc]['FP'][entry])  + '">' + wordDict['entry_' + str(i)] + '</error></strong></font>'
                    elif entry in errors[doc]['FN']:
                        outputParagraph[i] = '<font style="background-color:gold"><strong><error id="' + str(entry) + '" gs="GS_ONLY_ENTRY" eng="' + str(errors[doc]['FN'][entry])  + '">' + wordDict['entry_' + str(i)] + '</error></strong></font>'
        output.append('<context doc="' + doc + '">' + "".join(outputParagraph) + '</context>')

    output = "<contexts>" + "".join(output) + "</contexts>"

    allContexts = path + "allContexts.xhtml"
    
    with open(os.path.join(path, allContexts), 'w') as allContextsXML:
        allContextsXML.write(output)
    allContextsXML.close()

    #reparsing the output so as to proceed to add it to a final xhtml format:
    finalOutput = ET.parse(allContexts, parser=parser)

    allContextsPerDoc = finalOutput.findall('context')
        
    allContextsTable = TElement('table', parent=body)
    allContextsTable.attrib['id'] = "KWIC"

    for context in allContextsPerDoc:
        allContextsTable.append(TElement('h3', text=context.get('doc')))
        allContextsTable.append(context)
        allContextsTable.append(TElement('p', parent=allContextsTable))

    # for the file it's hashed to, if some entry numbers appeared in false positives or false negatives, get all text descendents from paragraph nodes 
    with open(os.path.join(path, "KWIC_out.xhtml"), 'w') as outputFile:
        for i in range(len(root)):
            outputFile.write(ET.tostring(root[i]))
    outputFile.close()


class TElement(ET._Element):
    """Extending elementtree's Element class so as to accommodate text"""
    def __init__(self, tag, style=None, text=None, tail=None, parent=None, attrib={}, **extra):
        ET._Element.__init__(self, tag, dict(attrib, **extra))
        
        if text:
            self.text = text
        if tail:
            self.tail = tail
        if style:
            self.style = style
        if not parent == None:
            parent.append(self)

## Begin processing...
docCount=0
# Filter only xml files as the file type to be tested
docs = filter(lambda x: str(x.split('.')[len(x.split('.'))-1]) == 'xml' , os.listdir(path))

# Labels to be tested -- implement later as a dictionary later so as to accommodate Certainty, Temporality, Subject, Acuity, etc.
matrixValues = [(u'LAST_NAME',), (u'MALE_NAME',), (u'FEMALE_NAME',), (u'PHONE_NUMBER',), (u'MEDICAL_RECORD_NUMBER',), (u'ABSOLUTE_DATE',), (u'DATE',), 
(u'ADDRESS',), (u'LOCATION',), (u'AGE',), (u'SOCIAL_SECURITY_NUMBER',), (u'CERTIFICATE_OR_LICENSE_NUMBER',), (u'ID_OR_CODE_NUMBER',), (u'NAME',),
(u'ORGANIZATION',), (u'URL',), (u'E_MAIL_ADDRESS',), (u'TIME',), (u'OTHER',), (u'HOSPITAL',), (u'INITIAL',), (u'HOSPITAL_SUB',)]

allData = {}
truePosCount = 0
falseNegCount = 0
falsePosCount = 0
confusionMatrix = {}
incompOverlaps = {}
compOverlaps = {}
finalIncompOverlaps = {}
truePosFromOverlaps = {}
truePosWithOverlaps = {}

#for engine only or gs only MIMs
fnDic = {}
fpDic = {}
        # will be used in referencing FN and FP (for MIMs occuring only in the engine) counts in the matrix table rendering below
fnDic = {}
for value in matrixValues:
    fnDic[value] = 0

fpDic = {}
for value in matrixValues:
    fpDic[value] = 0

errors = {}
truePositives = {}
gsDic = {}
engDic = {}

for doc in docs:
    if not doc.endswith('.out.xml'):
        docCount += 1
        
        print "\n\n_______________________________________\n"
        print "Now running document %s out of %s..." % (docCount, len(docs)/2)
        print "_______________________________________\n\n"
        parsedGSDoc = parse(path + '\\' + doc)
        parsedEngDoc = parse(findPair(path + '\\' + doc))
        
        outputList = []
        documentText = {}
                
        # Creates rows and columns for the matrix labeled with codes(matrixValues)
        # Instantiates each false/true positive count to 0
        confusionMatrix[doc] = {}
        for value in matrixValues:
            confusionMatrix[doc][value] = {}
            for value2 in matrixValues:
                confusionMatrix[doc][value][value2] = 0
        
        # Establishing the gold standard data structures
        
        #  assmpt: the gold standard set is perfect & 1:1 
        gsDic[doc] = {}
        entries = parsedGSDoc.getElementsByTagName('entry')
        for entry in entries:
            bindings = []
            for child in entry.firstChild.childNodes:
                if child.localName == 'binding':
                    bindings.extend([narrativeBindings.getAttribute('ref') for narrativeBindings in child.childNodes])
                    entries = tuple(str(binding) for binding in bindings if len(binding)>0)
                    value = [child.getAttribute('code') for child in entry.firstChild.childNodes if child.localName == 'code'] # added if filter here, because why would we need the manual validation codes? 
                    gsDic[doc][entries] = value
        for k, v in gsDic[doc].items():
            gsDic[doc][k] = tuple(v)

        #print "gsDic : ", gsDic 
                        
        # if the gold standard isn't perfect + has overlapping entries, it will be seen here but is not yet tested/fixed

        # --> Create alert that funnels gs documents having overlapping MIMs and output at end of script
        
        ## Establishing the engine data structures
        engDic[doc] = {}
        entries = parsedEngDoc.getElementsByTagName('entry')
        for entry in entries:
            bindings = []
            for child in entry.firstChild.childNodes:
                if child.localName == 'binding':
                    bindings.extend([narrativeBindings.getAttribute('ref') for narrativeBindings in child.childNodes])
                    entries = tuple(str(binding) for binding in bindings if len(binding)>0)
                    value = [child.getAttribute('code') for child in entry.firstChild.childNodes if child.localName == 'code'] # added if filter here, because why would we need the manual validation codes? 
                    if entries in engDic[doc]:
                        engDic[doc][entries].append("".join(value))
                    else:
                        engDic[doc][entries] = value
        for k, v in engDic[doc].items():
            engDic[doc][k] = tuple(v)
         
##        ## Begin comparison of data structures
##
##        #Overlaps handling needs to go right here:
##        overlaps[doc] = {}
##        #the only case for overlaps lies with multi-token MIMs, because otherwise complete overlaps with the same code are caught as they should be elswhere
##        gsKeys = sorted(filter(lambda x: len(x) > 1, gsDic[doc].keys()))
##        for entry in gsKeys:
##            for string in entry:
##                # if the previous entry number OR the  is in the engDic and the entry tuple that it lies within corresponds to the same code value
##                for engEntry in engDic[doc].keys():
##                    #if there's +/-1 overlap, looking at the extremities of the two tuples, we want to append these to TPs.
##                    #If not, throw them into FPs and delete these keys from the data structures
##                    if "entry_" + str(int(string.split("_")[1])-1) in engEntry:
##                        print "entry_" + str(int(string.split("_")[1])-1) + "in engEntry"
##                        if "entry_" + str(int(string.split("_")[1])-1) == sorted(engEntry)[0]:
##                            if engDic[doc][engEntry] == gsDic[doc][entry]:
##                                print "compare these two to see that they have -1 scope difference: ", sorted(entry), sorted(engEntry)
##                    elif "entry_" + str(int(string.split("_")[1])+1) in engEntry:
##                        print "entry_" + str(int(string.split("_")[1])+1) + "in engEntry"
##                        if "entry_" + str(int(string.split("_")[1])+1) == sorted(engEntry)[-1]:
##                            if engDic[doc][engEntry] == gsDic[doc][entry]:
##                                print "compare these two to see that they have +1 scope difference: ", set(entry) & set(engEntry)
                                
                                
        # True Positives
        truePositives[doc] = {entry:tuple(gsDic[doc][entry]) for entry in gsDic[doc] if (entry in engDic[doc] and gsDic[doc][entry] == engDic[doc][entry])}
        # Handle multi-code entries as well, for instance gs: (entry_7,): (u'AGE'), eng: (entry_7,): (u'AGE', u'AGE') -kind of overlapping:
        for entry in gsDic[doc].keys():
            if entry in gsDic[doc].keys() and entry in engDic[doc].keys() and entry not in truePositives[doc]:
                truePositives[doc][entry] = tuple(code for code in gsDic[doc][entry])
            
        # Increments true positive counters in the confusion matrix
        for entry in gsDic[doc].keys():
            if entry in truePositives[doc] and truePositives[doc][entry] == tuple(gsDic[doc][entry]):
                if truePositives[doc][entry] in confusionMatrix[doc] and truePositives[doc][entry] in confusionMatrix[doc][truePositives[doc][entry]]:
                    #if entry in engDic and engDic[entry] == gsDic[entry] # If the value exists, increment it
                   confusionMatrix[doc][truePositives[doc][entry]][truePositives[doc][entry]] += 1
                # If the value doesn't exist, add another row/column for it
                else:
                    confusionMatrix[doc][truePositives[doc][entry]] = {}
                    for value2 in matrixValues:
                        confusionMatrix[doc][truePositives[doc][entry]][value2] = 0
                    confusionMatrix[doc][truePositives[doc][entry]][truePositives[doc][entry]] = 1
        #print "\n\nTrue Positives: (x%s found!)\n" % len(truePositives[doc])
        truePosCount += len(truePositives[doc])
        #print truePositives[doc]
        
        # Checking for false positives, false negatives, and mismatches...

        #False negatives:
        gsDiffs = {entry:gsDic[doc][entry] for entry in gsDic[doc] if entry not in engDic[doc]}
        #False positives: 
        engDiffs = {entry:engDic[doc][entry] for entry in engDic[doc] if entry not in gsDic[doc]}

        engDiffsOneToOne = {}
        for entry in engDiffs:
            if len(entry) > 1:
                for subentry in entry:
                    engDiffsOneToOne[(subentry,)] = engDiffs[entry]
            else:
                engDiffsOneToOne[entry] = engDiffs[entry]

        gsDiffsOneToOne = {}
        for entry in gsDiffs:
            if len(entry) > 1:
                for subentry in entry:
                    gsDiffsOneToOne[(subentry,)] = gsDiffs[entry]
            else:
                gsDiffsOneToOne[entry] = gsDiffs[entry]

        # errors has the structure {doc:{"FN":{entry:code, ...}, "FP":{entry:code, ...} }
        # -> being used by KWIC to provide error highlighting in contexts -- created the above 1:1 dics to facilitate that process for multi-token Mims
        errors[doc] = {}
        errors[doc]["FN"] = {}
        errors[doc]["FN"] = gsDiffsOneToOne
        errors[doc]["FP"] = {}
        errors[doc]["FP"] = engDiffsOneToOne

        # Increments false positive count
        # Checks whether entries that exist in the engine exist in the gold standard
        # If not, it's a false positive
        # NOTE: Doesn't include error checking. Basing it off the true positives' error checking
        for entry in engDic[doc]:
            # If value is in engine and not gs, increment
            if entry not in gsDic[doc]:
                if len(engDic[doc][entry]) > 1:
                    # check KeyError: (u'FEMALE_NAME', u'DATE') for doc 47/313 (probably 'B~ClinicalDocument_2531473614.xml')
                    for code in engDic[doc][entry]:
                        fpDic[(code,)] += 1
                else: fpDic[engDic[doc][entry]] += 1
##                if "ENGINE_ONLY_FP" in errorDic[doc]:
##                    print "x1 engine only entry in confMatrix, so now incrementing"
##                    errorDic[doc]["ENGINE_ONLY_FP"][engDic[doc][entry]] += 1
##                else:
##                    #no engine only entry found for this dic in confmatrix, making a new dic
##                    errorDic[doc]["ENGINE_ONLY_FP"] = {}
##                    for value in matrixValues:
##                        #initialize code from matrixValues to zero"
##                        errorDic[doc]["ENGINE_ONLY_FP"][value] = 0
##                    errorDic[doc]["ENGINE_ONLY_FP"][engDic[doc][entry]] += 1
            # Non-matching codes handling
            else:
                #if the entry numbers exist in both but the engineDic has a multi-code entry (meaning, overlapping MIMs)
                if len(engDic[doc][entry]) > 1:
                    for code in engDic[doc][entry]:
                        print "code that is in engDic[doc][entry]: ", code
                        if code not in gsDic[doc][entry]:
                            print "code that is not in gsDic[doc][entry]: ", code
                            confusionMatrix[doc][gsDic[doc][entry]][(code,)] += 1
                # Otherwise, entries exist in both but codes don't match (e.g, DATE =/= ABSOLUTE_DATE), increment false positive count
                elif gsDic[doc][entry] != engDic[doc][entry]:
                    confusionMatrix[doc][gsDic[doc][entry]][engDic[doc][entry]] += 1
        
        # Increments false negative count
        # Checks whether entries that exist in the gold standard exist in the engine
        # If not, it's a false negative
        # NOTE: Doesn't include error checking. Base it off the true positives' error checking
        for entry in gsDic[doc]:
            if entry not in engDic[doc]:
                fnDic[gsDic[doc][entry]] += 1
                print "initialized a false negative entry"

        ### gsDiffs = What the gold standard said was right ###
        ### engineDiffs = What the engine said was right ###

        print "\n\nDifferences in engine versus gold standard - " + doc + ":"
        print "_____________________________________________\n"
        print "In gold standard version but not in engine version (false negatives): (x%s found)" % len(gsDiffs)
        falseNegCount += len(gsDiffs)
        #print gsDiffs
        print ""
        #print "In engine version but not in gold standard version (false positives): (x%s found)" % len(engDiffs)
        falsePosCount += len(engDiffs)
        #print engDiffs
        print "\n\n"
        ### engineDiffs will contain false positives, scopeMismatchValueMatches, and ScopeMatchValueMismatch

        print("\nOverlap handling\n")
        incompOverlaps[doc] = {}
        compOverlaps[doc] = {}
        finalIncompOverlaps[doc] = {}
        incompleteOverlaps = 0
        completeOverlaps = 0
        for gsKeyTup in gsDic[doc].keys():
            for i in range(len(gsKeyTup)):
                for engKeyTup in engDic[doc].keys():
                    for j in range(len(engKeyTup)):
                        # If any value within the gsKey's tuple overlaps with the engineKey's tuple, count it as an overlap
                        if str(gsKeyTup[i]) == str(engKeyTup[j]):
                            #verifying codes are equal
                            if gsDic[doc][gsKeyTup] == engDic[doc][engKeyTup]:
                                if str(gsKeyTup) == str(engKeyTup):
                                    completeOverlaps += 1
                                    #print str(gsKeyTup)
                                    #print str(engKeyTup)
                                    print "Complete overlap occurs in " + str(gsKeyTup) + ", " + str(engKeyTup)
                                    print("%%%%%%%Complete overlaps: " + str(engKeyTup[j]) + " " + str(engKeyTup) + "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
                                    #adding entry tuple and code to the complete overlaps dictionary so as to get tossed into the KWIC function later
                                    compOverlaps[doc][gsKeyTup] = engDic[doc][engKeyTup]
                                else:
                                    print "Incomplete overlap occurs in" + str(gsKeyTup) + ", " + str(engKeyTup)
                                    print("&&&&&&&Incomplete overlaps: " + str(engKeyTup[j]) + " " + str(engKeyTup) + "&&&&&&&&&&&&")
                                    if list(sorted(engKeyTup)).reverse() != list(sorted(gsKeyTup)) and list(sorted(gsKeyTup)).reverse() != list(sorted(engKeyTup)) and list(sorted(gsKeyTup)) != list(sorted(engKeyTup)):
                                        incompOverlaps[doc][gsKeyTup] = engKeyTup
                                    incompleteOverlaps += 1
                    if completeOverlaps > 0 or incompleteOverlaps > 0:
                        #print str(gsKeyTup) + " : " + str(engKeyTup)
                        #print str(gsDic[doc][gsKeyTup]) + " : " + str(engDic[doc][engKeyTup])
                        #print("/////////////////////")
                        break
                if incompleteOverlaps > 0 or completeOverlaps > 0:
                    break
        print "complete overlap count: " + str(completeOverlaps)
        print "incomplete overlap count: " + str(incompleteOverlaps)

        print "comparison of engine and gs entry tuples to sort out TP from FP overlaps based on criteria"
        if incompOverlaps[doc]:
            for gsTup, engTup in incompOverlaps[doc].items():
                truePosFromOverlaps[doc] = {}
                if len(gsTup) < len(engTup):
                    print "length of engine tuple: ", len(engTup), " ", engTup, "  length of gs tuple (shorter): ", len(gsTup), " ", gsTup
                    testList = []
                    testList.append('entry_' + str(int(sorted(list(gsTup))[0].split("_")[1])-1))
                    print "after append #1: ", testList
                    testList.extend(sorted(list(gsTup)))
                    print "after append #2: ", testList
                    testList.append('entry_' + str(int(sorted(list(gsTup))[-1].split("_")[1])+1))
                    print "after append #3: ", testList
                    print "test list " + str(tuple(testList)) + " vs. engTup " + str(engTup)
                    if len(gsTup)*1.0 / len(engTup) >= 3/4:
                        truePosFromOverlaps[doc][engTup] = engDic[doc][engTup]
                    elif len(tuple(testList))*1.0 / len(engTup) >= 2/3:
                        if tuple(sorted(testList)) == tuple(sorted(list(engTup))):
                            #TP!
                            truePosFromOverlaps[doc][engTup] = engDic[doc][engTup]
                        else:
                            #FP...
                            finalIncompOverlaps[doc][engTup] = engDic[doc][engTup]
                    else:
                        finalIncompOverlaps[doc][engTup] = engDic[doc][engTup]
                        
                elif len(engTup) < len(gsTup):
                    print "length of engine tuple (shorter): ", len(engTup), " ", engTup, "  length of gs tuple: ", len(gsTup), " ", gsTup
                    testList = []
                    testList.append('entry_' + str(int(sorted(list(engTup))[0].split("_")[1])-1))
                    print "after append #1: ", testList
                    testList.extend(sorted(list(engTup)))
                    print "after append #2: ", testList
                    testList.append('entry_' + str(int(sorted(list(engTup))[-1].split("_")[1])+1))
                    print "after append #3: ", testList
                    print "test list " + str(testList) + " vs. gsTup " + str(gsTup)
                    if len(engTup)*1.0 / len(gsTup) >= 3/4: #75% match condition
                        truePosFromOverlaps[doc][engTup] = engDic[doc][engTup]
                    elif len(tuple(testList))*1.0 / len(gsTup) >= 2/3: #this and next 'if' statement being the "plus or minus one token on either side" condition
                        if tuple(sorted(testList)) == tuple(sorted(list(gsTup))):
                            #TP!
                            truePosFromOverlaps[doc][engTup] = engDic[doc][engTup]
                        else:
                            #FP...
                            finalIncompOverlaps[doc][engTup] = engDic[doc][engTup]
                    else:
                        finalIncompOverlaps[doc][engTup] = engDic[doc][engTup]
##
##print "incomplete overlaps"
##for doc in docs:
##    if not doc.endswith('.out.xml'):
##        print "________________________________________________________"
##        print doc
##        print "\n\n TPs!"
##        if doc in truePosFromOverlaps:
##            print truePosFromOverlaps[doc]
##        print "\n\n\nfinal incomplete overlaps"
##        print finalIncompOverlaps[doc]
                        
            #want to compbine the true positives and the overlap-derived true positives so as to retake statistics on these separately
            #this method below is wrong though -- need to put any additional overlaps in the same document.
            
            truePosWithOverlaps[doc] = {}
            truePosWithOverlaps[doc] = dict(truePosFromOverlaps[doc].items() + truePositives[doc].items())


# TEST CODE for truePos + overlaps mergings
##    for doc in docs:
##	if not doc.endswith('.out.xml'):
##		print "__________"
##		print doc
##		print truePosWithOverlaps[doc]
##		print truePositives[doc]
##		if truePosWithOverlaps[doc] == truePositives[doc]:
##			print "SAME"
##		else:
##			print "NOT SAME -- dict has properly merged!"
##			break
